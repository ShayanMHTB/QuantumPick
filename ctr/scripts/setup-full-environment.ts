import { ethers } from 'hardhat';
import fs from 'fs';
import path from 'path';
import { setupWallets } from './setup-wallets';
import { deployStablecoins } from './deploy-stablecoins';
import { deployLotteryContracts } from './deploy-lottery-contracts';

interface EnvironmentConfig {
  wallets: any;
  stablecoins: any;
  lotteryContracts: any;
  timestamp: string;
  network: string;
}

async function setupFullEnvironment() {
  console.log('ðŸš€ Setting up full QuantumPick development environment...\n');

  try {
    // Step 1: Setup wallets
    console.log('=== Step 1: Setting up wallets ===');
    const wallets = await setupWallets();

    // Step 2: Deploy stablecoins
    console.log('\n=== Step 2: Deploying stablecoins ===');
    const stablecoins = await deployStablecoins();

    // Step 3: Deploy lottery contracts
    console.log('\n=== Step 3: Deploying lottery contracts ===');
    const lotteryContracts = await deployLotteryContracts();

    // Step 4: Create initial sample lottery
    console.log('\n=== Step 4: Creating sample lottery ===');
    await createSampleLottery(wallets, stablecoins, lotteryContracts);

    // Step 5: Save complete environment configuration
    const envConfig: EnvironmentConfig = {
      wallets,
      stablecoins,
      lotteryContracts,
      timestamp: new Date().toISOString(),
      network: 'hardhat',
    };

    const outputDir = path.join(__dirname, './generated');
    fs.writeFileSync(
      path.join(outputDir, 'environment.json'),
      JSON.stringify(envConfig, null, 2),
    );

    // Create a .env.local file for frontend/backend consumption
    const envContent = `
# Generated by setup-full-environment.ts
# Network Configuration
NETWORK_NAME=hardhat
NETWORK_CHAIN_ID=31337

# Platform Wallets
PLATFORM_OWNER_ADDRESS=${wallets.platform.owner.address}
PLATFORM_FEE_COLLECTOR_ADDRESS=${wallets.platform.feeCollector.address}

# Contract Addresses
MOCK_USDC_ADDRESS=${stablecoins.MockUSDC}
MOCK_DAI_ADDRESS=${stablecoins.MockDAI}
MOCK_USDT_ADDRESS=${stablecoins.MockUSDT}
LOTTERY_FACTORY_ADDRESS=${lotteryContracts.LotteryFactory}
VRF_COORDINATOR_ADDRESS=${lotteryContracts.VRFCoordinator}

# Development Keys (DO NOT USE IN PRODUCTION)
DEPLOYER_PRIVATE_KEY=${wallets.platform.owner.privateKey}
`.trim();

    fs.writeFileSync(path.join(outputDir, '.env.local'), envContent);

    console.log('\nâœ… Environment setup complete!');
    console.log('\nðŸ“ Generated files:');
    console.log('  - generated/wallets.json');
    console.log('  - generated/stablecoins.json');
    console.log('  - generated/lottery-contracts.json');
    console.log('  - generated/environment.json');
    console.log('  - generated/.env.local');

    console.log('\nðŸ”‘ Key addresses:');
    console.log(`  Platform Owner: ${wallets.platform.owner.address}`);
    console.log(`  USDC Contract: ${stablecoins.MockUSDC}`);
    console.log(`  Lottery Factory: ${lotteryContracts.LotteryFactory}`);

    return envConfig;
  } catch (error) {
    console.error('âŒ Error setting up environment:', error);
    throw error;
  }
}

async function createSampleLottery(
  wallets: any,
  stablecoins: any,
  contracts: any,
) {
  const [deployer] = await ethers.getSigners();
  const creator = await ethers.getSigner(wallets.creators[0].address);

  console.log('Creating sample lottery with creator:', creator.address);

  // Get factory contract
  const factory = await ethers.getContractAt(
    'LotteryFactory',
    contracts.LotteryFactory,
  );

  // Lottery parameters
  const currentTime = Math.floor(Date.now() / 1000);
  const lotteryParams = {
    tokenAddress: stablecoins.MockUSDC,
    ticketPrice: ethers.parseUnits('10', 6), // 10 USDC
    maxTickets: 1000,
    minTickets: 10,
    startTime: currentTime + 60, // Start in 1 minute
    endTime: currentTime + 86400, // End in 24 hours
    drawTime: currentTime + 86500, // Draw 100 seconds after end
    prizePercentages: [5000, 3000, 2000], // 50%, 30%, 20%
  };

  // Create lottery
  const tx = await factory
    .connect(creator)
    .createLottery(
      lotteryParams.tokenAddress,
      lotteryParams.ticketPrice,
      lotteryParams.maxTickets,
      lotteryParams.minTickets,
      lotteryParams.startTime,
      lotteryParams.endTime,
      lotteryParams.drawTime,
      lotteryParams.prizePercentages,
    );

  const receipt = await tx.wait();
  const event = receipt?.logs.find((log: any) => {
    try {
      const parsed = factory.interface.parseLog({
        topics: log.topics,
        data: log.data,
      });
      return parsed?.name === 'LotteryCreated';
    } catch {
      return false;
    }
  });

  if (event) {
    const parsed = factory.interface.parseLog({
      topics: event.topics,
      data: event.data,
    });
    const lotteryAddress = parsed?.args.lotteryAddress;
    console.log('Sample lottery created at:', lotteryAddress);

    // Convert BigInt values to strings for JSON serialization
    const serializableParams = {
      tokenAddress: lotteryParams.tokenAddress,
      ticketPrice: lotteryParams.ticketPrice.toString(),
      maxTickets: lotteryParams.maxTickets,
      minTickets: lotteryParams.minTickets,
      startTime: lotteryParams.startTime,
      endTime: lotteryParams.endTime,
      drawTime: lotteryParams.drawTime,
      prizePercentages: lotteryParams.prizePercentages,
    };

    // Save sample lottery address
    const outputDir = path.join(__dirname, './generated');
    fs.writeFileSync(
      path.join(outputDir, 'sample-lottery.json'),
      JSON.stringify(
        {
          address: lotteryAddress,
          creator: creator.address,
          params: serializableParams,
          timestamp: new Date().toISOString(),
        },
        null,
        2,
      ),
    );
  }
}

// Run if called directly
if (require.main === module) {
  setupFullEnvironment()
    .then(() => process.exit(0))
    .catch((error) => {
      console.error(error);
      process.exit(1);
    });
}

export { setupFullEnvironment };
